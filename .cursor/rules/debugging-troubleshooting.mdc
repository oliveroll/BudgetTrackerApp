---
alwaysApply: true
description: Debugging guide, common issues, and troubleshooting solutions
---

# Debugging & Troubleshooting Guide

## 1. Variable Scope & Callbacks

### Rule: Always Verify Variable Scope
- **Before using a variable inside a function**, verify it's accessible in that scope
- **Pass variables explicitly** via parameters or callbacks
- **Never rely on implicit/global scope** for critical data (e.g., `transactions`, `expenses`)

### Common Pattern:
```kotlin
// ❌ WRONG - Trying to access parent scope variable
fun ChildComponent(item: Item) {
    Button(onClick = { 
        parentList.remove(item) // ❌ parentList not in scope!
    })
}

// ✅ CORRECT - Pass callback to parent
fun ChildComponent(
    item: Item,
    onItemRemoved: (Item) -> Unit // ✅ Explicit callback
) {
    Button(onClick = { onItemRemoved(item) })
}
```

---

## 2. Correct Component / Function Target

### Rule: Confirm the Active Function Before Editing

**Problem:** Editing unused legacy functions while the real UI uses a different one.

**Example from this project:**
- `AnimatedIncomeExpensesCard` was **unused**
- `UnifiedFinancialOverviewCard` was the **actual rendered function**
- Edits to the wrong function had zero effect!

### Prevention Checklist:
1. **Add temporary logs** to confirm function is invoked:
   ```kotlin
   Log.d("DEBUG_RENDER", "UnifiedFinancialOverviewCard is rendering")
   ```

2. **Search for function calls** in the codebase:
   ```bash
   grep -r "FunctionName" --include="*.kt"
   ```

3. **If logs don't appear**, stop and trace the call hierarchy:
   - Check navigation routes
   - Check parent composables
   - Verify the function is actually called

4. **Remove debug logs** after confirming the correct target

---

## 3. Debugging Discipline

### Always Use Temporary Debug Logs
```kotlin
// At function entry
Log.d("MyScreen", "=== RENDERING MyScreen ===")

// At critical calculation points
Log.d("MyScreen", "Calculated value: $result")

// In callbacks
Log.d("MyScreen", "Button clicked, state before: $state")
```

### Remove Debug Code After Fixing
- Never commit debug logs to production
- Use `TAG` constants for easy cleanup:
  ```kotlin
  private const val TAG = "DebugMyFeature" // Easy to find and remove
  ```

### Debugging Workflow:
1. **Add logs** to trace execution path
2. **Run app** and check logcat
3. **Identify issue** from logs
4. **Fix the issue**
5. **Remove all debug logs** before committing

---

## 4. Feature Implementation Scope

### Rule: Ensure Full Integration

When implementing a new feature, verify it flows through **all layers**:

**Example: Adding expense bar colors**
1. ✅ **Data Layer:** Calculate fixed expenses correctly
   ```kotlin
   .filter { it.dueDay != null } // Only Fixed expenses
   ```

2. ✅ **ViewModel Layer:** Expose data to UI
   ```kotlin
   val fixedExpensesTotal = /* calculation */
   ```

3. ✅ **UI Layer:** Render in the ACTUAL displayed component
   ```kotlin
   // Verify this function is called!
   @Composable
   fun ActualRenderedCard() { ... }
   ```

4. ✅ **State Management:** React to data changes
   ```kotlin
   LaunchedEffect(budgetUiState.lastUpdated) {
       // Reload when data changes
   }
   ```

### Integration Checklist:
- [ ] Data calculated correctly
- [ ] ViewModel exposes data
- [ ] UI receives data
- [ ] UI actually renders (confirmed with logs)
- [ ] State updates trigger re-render
- [ ] Changes visible in running app
- [ ] Debug logs removed

---

## 5. General Rules

### Never Assume - Always Confirm
- ❌ **Don't assume** a function is used because it exists
- ✅ **Confirm** with logs, search, or breakpoints

### Multiple Similar Functions
When you find multiple similar functions (e.g., `AnimatedCard`, `ModernCard`, `UnifiedCard`):
1. **Document which one is active** in comments
2. **Consider removing unused ones** to avoid confusion
3. **Add a comment** at the top of unused functions:
   ```kotlin
   // ⚠️ UNUSED - Real implementation is in UnifiedFinancialOverviewCard
   @Composable
   fun AnimatedIncomeExpensesCard() { ... }
   ```

### Build + Run Before Marking Complete
- Always **build** the project after changes
- Always **run on device/emulator** to verify
- Never mark a task complete without visual confirmation

---

## Common Issues in This Project

### Issue: Dashboard not showing Fixed/Subscription colors
**Root Cause:** Editing `AnimatedIncomeExpensesCard` instead of `UnifiedFinancialOverviewCard`  
**Prevention:** Add `Log.d("RENDER", "...")` to confirm which function renders

### Issue: Variable out of scope errors
**Root Cause:** Trying to access parent scope variables in child components  
**Prevention:** Always pass data via parameters or callbacks

### Issue: State not updating after data changes
**Root Cause:** Missing `LaunchedEffect` to reload on data changes  
**Prevention:** Add `LaunchedEffect(dependency)` for reactive updates

### Issue: Filters not applied correctly
**Root Cause:** Summing all items instead of filtering by criteria  
**Example:** Use `.filter { it.dueDay != null }` for Fixed expenses only

---

## Debugging Tools for This Project

### LogCat Filtering
```bash
# Filter by tag
adb logcat -s "BudgetDebug"

# Filter by package
adb logcat | grep "com.budgettracker"
```

### Quick Debugging Composables
```kotlin
// Add to any composable to see when it recomposes
Log.d("Recompose", "MyComposable recomposing")
SideEffect {
    Log.d("Recompose", "SideEffect in MyComposable")
}
```

### State Inspection
```kotlin
// Log state changes
LaunchedEffect(myState) {
    Log.d("StateChange", "myState changed to: $myState")
}
```

---

## Summary: The Golden Rules

1. **Verify scope** - Don't assume variables are accessible
2. **Confirm target** - Use logs to verify which function renders
3. **Debug systematically** - Add logs, test, fix, remove logs
4. **Check all layers** - Data → ViewModel → UI → State
5. **Never assume** - Always confirm with evidence
6. **Test on device** - Visual confirmation before marking complete
